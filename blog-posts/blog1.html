<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Habits for Grads - Blog - Matteo Carucci</title>

    <link rel="shortcut icon" href="../assets/images/MC_logo.ico" type="image/x-icon">
    <link rel="stylesheet" href="../assets/css/style.css"> <!-- Link to main stylesheet -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">

    <!-- Google Tag -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LXQLH66J4S"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-LXQLH66J4S');
    </script>

    <!-- Specific CSS for blog post elements and overrides -->
    <style>
        /* --- Fixes for Blog Post Content --- */
        .blog-post-text ul {
          list-style: disc !important;
          list-style-position: outside !important;
          margin-left: 0 !important;
          padding-left: 40px !important;
        }
        .blog-post-text ol {
          list-style: decimal !important;
          list-style-position: outside !important;
          margin-left: 0 !important;
          padding-left: 40px !important;
        }
        .blog-post-text li {
          display: list-item !important;
          list-style: inherit !important;
          padding-left: 5px;
          margin-bottom: 0.8em;
        }
        .blog-post-text p a,
        .blog-post-text li a {
          display: inline !important; /* Allow links to flow inline */
          width: auto !important;
        }
        /* --- End of Fixes --- */


        /* --- Layout Overrides for Full Width Post --- */
        .main-content {
            margin-left: 0;
            width: 100%;
            max-width: none;
            border-radius: 0;
            box-shadow: none;
            border: none;
            padding: 0;
        }
        /* Left-align the content block instead of centering */
        .blog-post-content-wrapper {
             max-width: 900px; /* Readability constraint */
             margin-left: 0;  /* Left align */
             margin-right: 0; /* Left align */
             padding: 0 clamp(20px, 5vw, 60px); /* Responsive padding */
        }
        .navbar { /* Adjust if needed based on main CSS */ }

        /* --- General Blog Post Styling --- */
        .blog-post-article {
            padding-top: 80px; /* Space below navbar */
            padding-bottom: 50px;
        }
        .blog-post-content { color: var(--light-gray); }
        .blog-post-text p,
        .blog-post-text li {
            line-height: 1.8;
        }
        .blog-post-text p {
             margin-bottom: 1.3em;
        }
        .blog-post-text ul, .blog-post-text ol {
             margin-bottom: 1.3em;
        }
        .blog-post-text strong {
             color: var(--white-1);
             font-weight: 600;
        }
        .blog-post-banner {
            display: block;
            max-width: 700px; /* Adjust image width */
            margin-left: auto;
            margin-right: auto;
            margin-bottom: 45px;
            border-radius: 12px;
            overflow: hidden;
            background-color: var(--eerie-black-2);
            border: 1px solid var(--jet);
            box-shadow: var(--shadow-2);
         }
        .blog-post-banner img {
            display: block;
            width: 100%;
            height: auto;
            object-fit: cover;
        }
        /* Left-align the main title instead of centering */
         .blog-post-article header .article-title {
            text-align: left;
            margin-bottom: 1.8em;
            padding: 0;
         }
        .blog-post-content h3 {
            margin-top: 2.8em;
            margin-bottom: 1.2em;
             color: var(--white-1);
             border-bottom: 2px solid var(--orange-yellow-crayola);
             padding-bottom: 10px;
             font-size: 1.6rem;
        }
         .blog-post-content h4 {
             margin-top: 2.2em;
             margin-bottom: 1em;
             color: var(--white-2);
             font-weight: 600;
             font-size: 1.25rem;
             border-left: 3px solid var(--orange-yellow-crayola);
             padding-left: 12px;
         }
         /* NEW: Style for h5 sub-subheadings */
         .blog-post-text h5 {
            font-size: 1.15rem; /* Size between p and h4 */
            font-weight: 600;   /* Bold */
            color: var(--white-1); /* Bright white */
            margin-top: 1.8em;  /* Space above */
            margin-bottom: 0.8em; /* Space below */
            text-transform: none; /* Override capitalize if needed */
         }
         /* General link styles */
         .blog-post-content a {
             color: var(--orange-yellow-crayola);
             text-decoration: none;
             font-weight: 500;
             transition: color 0.2s ease, text-decoration 0.2s ease;
         }
         .blog-post-content a:hover {
             color: hsl(45, 100%, 80%);
             text-decoration: underline;
         }
         /* Specific underline for inline links */
        .blog-post-text p a,
        .blog-post-text li a {
             border-bottom: 1px dotted var(--orange-yellow-crayola);
        }
        .blog-post-text p a:hover,
        .blog-post-text li a:hover {
             border-bottom-style: solid;
        }

        /* Code block styles */
        .blog-post-content pre,
        .code-block {
            background-color: var(--onyx);
            color: #c5c8c6;
            padding: 20px 22px;
            border-radius: 10px;
            overflow-x: auto;
            font-family: 'Fira Code', 'Source Code Pro', Consolas, monospace;
            font-size: 0.92rem;
            line-height: 1.7;
            margin: 30px 0;
            border: 1px solid var(--jet);
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        .commit-example {
             margin: 8px 0 15px 0 !important;
             font-size: 0.88em !important;
             padding: 10px 15px !important;
             box-shadow: none !important;
             background-color: #2d2d2d !important;
        }
        .blog-post-content code:not(pre > code) { /* Inline code */
            background-color: hsla(210, 4%, 18%, 0.8);
            color: #ffcc99;
            padding: 0.3em 0.55em;
            border-radius: 5px;
            font-size: 0.9em;
            border: 1px solid var(--jet);
            vertical-align: baseline;
            font-family: 'Fira Code', 'Source Code Pro', Consolas, monospace;
        }
        /* Table styles */
        .blog-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin: 35px 0;
            font-size: 0.95em;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            border: 1px solid var(--jet);
            border-radius: 10px;
            overflow: hidden;
        }
        .blog-table th,
        .blog-table td {
            border: none;
            border-bottom: 1px solid var(--smoky-black-3);
            padding: 14px 18px;
            text-align: left;
            vertical-align: top;
        }
         .blog-table tbody tr:last-child td {
            border-bottom: none;
        }
        .blog-table th {
            background: linear-gradient(to bottom, var(--eerie-black-2), var(--onyx));
            font-weight: 600;
            color: var(--white-1);
            text-transform: uppercase;
            font-size: 0.88em;
            letter-spacing: 0.8px;
            border-bottom: 2px solid var(--orange-yellow-crayola);
        }
        .blog-table tbody tr {
            background-color: var(--eerie-black-1);
            transition: background-color 0.2s ease;
        }
        .blog-table tbody tr:nth-child(even) {
             background-color: var(--onyx);
        }
         .blog-table tbody tr:hover {
             background-color: var(--eerie-black-2);
         }
    </style>

</head>

<body>

    <main>
        <!-- SIDEBAR IS REMOVED -->

        <!-- Main Content Area -->
        <div class="main-content">

            <!-- NAVBAR -->
            <nav class="navbar">
                <ul class="navbar-list">
                <li class="navbar-item">
                    <a href="../index.html" class="navbar-link">Home</a>
                </li>
                <li class="navbar-item">
                    <a href="../resume.html" class="navbar-link">Resume</a>
                </li>
                <li class="navbar-item">
                    <a href="../blog.html" class="navbar-link active">Blog</a>
                </li>
                </ul>
            </nav>

            <!-- BLOG POST ARTICLE -->
            <article class="blog-post-article active" data-page="blog-post">

                <!-- Wrapper to constrain width and center content -->
                <div class="blog-post-content-wrapper">

                    <header>
                        <h2 class="h2 article-title">From Notebook Chaos to Production Calm: Git Habits for Grads</h2>
                    </header>

                    <!-- Container for styling -->
                    <section class="blog-post-content">

                        <figure class="blog-post-banner">
                            <!-- Make sure this image exists -->
                            <img src="../assets/images/git-meme.jpg" alt="Conceptual image representing Git version control or code structure" loading="lazy">
                        </figure>

                        <!-- Text content container -->
                        <div class="blog-post-text">

                            <h3>Preface: Why Your CS or Data Science Degree Left You Under-armed</h3>

                            <p>
                                Most universities still hand you a Jupyter notebook and call it "software engineering" or "data science", often overlooking how that work can be effectively shared, versioned, and reliably reproduced. Notebooks are fantastic for exploration and rapid prototyping, but try running a <code>git diff</code> on a <code>.ipynb</code> file â€“ you'll find yourself deciphering a complex JSON structure, making meaningful version tracking difficult. Critical skills like robust version control with Git, writing repeatable tests, and establishing deployable project structures rarely get the spotlight they deserve in academia. Yet, these are precisely the practices that bridge the gap between classroom exercises and maintainable, production-ready code. I learned this the hard way.
                            </p>

                            <h3>The Day Two Weeks Vanished (Not Pleasant)</h3>

                            <p>
                                During an internship, I was deep in the zone, fueled by the success of a new project: a data pipeline feeding a FastAPI service. Endpoints were responsive, documentation was auto-generated via Swagger (if you're unfamiliar, check it out <a href="https://swagger.io/docs/" target="_blank" rel="noopener noreferrer">here</a> â€“ it's incredibly useful). I kept telling myself I'd push my changes to the remote repository soon, just after tidying up a few more handlers and modules. Then, disaster struck. The laptop fan whirred violently, the screen went black, and my machine refused to boot. No recent push, no separate branch, no cloud backup. ðŸŽ¬ The result? A fresh OS install and two painstaking weeks spent reconstructing my work entirely from memory.
                            </p>

                            <h3>Lesson #1: If It Isn't On a Remote, It Doesn't Exist.</h3>
                            <p><em>(This title reflects the painful lesson learned above. The following points cover the essential habits *before* you push, ensuring what you push is valuable.)</em></p>

                            <h4>1. Commit Like Future-You is Debugging at 2 a.m.</h4>
                            <ul>
                                <li><strong>One Logical Change Per Commit:</strong> Keep commits small and focused. This makes reviewing easier (for yourself and others) and reverting changes trivial if something goes wrong.</li>
                                <li><strong>Write Clear Commit Messages:</strong> Use a consistent format. A simple, effective one is: <code><verb>: <what was changed> â€“ <why it was changed></code>.
                                    <pre class="code-block commit-example"><code>feat: add user authentication endpoint â€“ secures access to profile data</code></pre>
                                    <pre class="code-block commit-example"><code>fix: correct calculation error in reporting module â€“ prevents negative totals</code></pre>
                                    <pre class="code-block commit-example"><code>refactor: simplify database query logic â€“ improves performance by 15%</code></pre>
                                </li>
                                <li><strong>Link to Issues/Tickets:</strong> If using a tracker like Jira or GitHub Issues, include the ID (e.g., <code>#123</code> or <code>PROJ-456</code>) in your commit message. This automatically links your code changes to the requirement or bug report.</li>
                                <li><strong>Squash Merges (Carefully):</strong> Using squash-and-merge when completing a feature branch can keep your main branch history clean and linear. However, <strong>never</strong> squash commits *during* an active code review. The individual commits form the narrative of your development process and the review conversation.</li>
                            </ul>

                            <h4>2. Push Early, Push Often (The Cloud is Your Safety Net)</h4>
                            <p>Treat <code>git push</code> like hitting "Save" in the cloud. Don't wait until everything is "perfect."</p>
                            <ul>
                                <li>Finished a small, logical piece of work? <strong>Push it!</strong></li>
                                <li>Stepping away for lunch or a meeting? <strong>Push it!</strong></li>
                                <li>Trying out an idea on a separate branch? <strong>Push the branch!</strong></li>
                                <li>Fixed a tiny typo in the README? <strong>Push it!</strong> (Okay, maybe less critical, but it reinforces the habit and keeps the remote truly up-to-date).</li>
                            </ul>
                            <p>Pushing frequently triggers your Continuous Integration (CI) pipeline (if configured), giving you immediate feedback on tests and builds. It's your best defense against hardware failure, accidental deletions, or the dreaded blue screen of death.</p>

                            <h4>3. Branch Out: The Superpower of Parallel Universes (aka Branching)</h4>
                            <p>
                                Imagine you want to try a new idea, fix a bug, or add a feature. If you do this directly on your main codebase (<code>main</code> or <code>master</code>), and something goes wrong, untangling it can be a nightmare. This is where Git branches shine â€“ they are like creating a parallel universe for your code.
                            </p>
                            <h5>Why Branch?</h5>
                            <ul>
                                <li><strong>Isolation:</strong> Work on features or fixes without affecting the stable main codebase. If your experiment fails, you just discard the branch â€“ no harm done to main.</li>
                                <li><strong>Collaboration:</strong> Multiple people can work on different features simultaneously on their own branches.</li>
                                <li><strong>Clear History:</strong> When a feature is complete, its branch can be merged back, often through a Pull/Merge Request, creating a clean, reviewable history point.</li>
                                <li><strong>Experimentation:</strong> Want to try a risky refactor or a completely new approach? Do it on a branch!</li>
                            </ul>
                            <h5>Common Branching Workflow:</h5>
                            <ol>
                                <li><strong>Stay Updated:</strong> Before starting new work, make sure your local main branch is up-to-date with the remote:
                                    <pre class="code-block"><code>git checkout main
git pull origin main</code></pre>
                                </li>
                                <li><strong>Create & Switch:</strong> Create a new branch for your task (e.g., <code>feature/user-login</code> or <code>bugfix/payment-error</code>):
                                    <pre class="code-block"><code>git checkout -b feature/user-login

# This is a shortcut for:
# git branch feature/user-login
# git checkout feature/user-login

# Or using the newer 'switch' command:
# git switch -c feature/user-login</code></pre>
                                </li>
                                <li><strong>Work & Commit:</strong> Make your changes, commit them (following Lesson #1!) to your feature branch.</li>
                                <li><strong>Push Your Branch:</strong> Regularly push your branch to the remote (following Lesson #2!):
                                    <pre class="code-block"><code>git push origin feature/user-login</code></pre>
                                </li>
                                <li><strong>Iterate:</strong> Continue working, committing, and pushing to your branch.</li>
                                <li><strong>Merge (Often via Pull/Merge Request):</strong> Once your feature is complete and reviewed (if on a team), it gets merged back into the main branch.</li>
                            </ol>
                            <p>
                                Branches are cheap and easy in Git. Don't be afraid to use them for everything â€“ even a tiny change is often best done on a branch. This habit will save you countless headaches and make collaboration a breeze.
                            </p>

                            <h4>4. The Inevitable Merge: Understanding and Resolving Conflicts</h4>
                            <p>
                                So, you've been working diligently on your feature branch, and <code>main</code> has also seen some action. Now it's time to bring your changes back into <code>main</code>. This is done via a <code>git merge</code>. Most of the time, Git is smart enough to combine the changes automatically. But sometimes, Git gets confused â€“ this is a merge conflict.
                            </p>
                            <h5>What is a Merge Conflict?</h5>
                            <p>A merge conflict occurs when Git can't automatically resolve differences in code between two branches that are being merged. This typically happens when the same lines of code were changed in different ways on both branches since they diverged.</p>
                            <h5>Don't Panic! Conflicts are Normal</h5>
                            <p>Every developer encounters merge conflicts. The key is to understand how to resolve them calmly.</p>
                            <h5>The Conflict Resolution Dance:</h5>
                            <ol>
                                <li><strong>Initiate the Merge:</strong> First, ensure your current branch is the one you want to merge into (e.g., <code>main</code>), and it's up-to-date. Then, merge your feature branch:
                                    <pre class="code-block"><code>git checkout main
git pull origin main # Ensure main is up-to-date
git merge feature/user-login</code></pre>
                                </li>
                                <li><strong>Identify Conflicts:</strong> If there are conflicts, Git will tell you:
                                    <pre class="code-block"><code>Auto-merging src/my_awesome_service/api/users.py
CONFLICT (content): Merge conflict in src/my_awesome_service/api/users.py
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
                                    <code>git status</code> will also show you the unmerged paths.
                                </li>
                                <li><strong>Open the Conflicted File(s):</strong> Inside the file(s) Git flagged, you'll see markers like this:
                                    <pre class="code-block"><code><<<<<<< HEAD
# Code from your current branch (e.g., main)
def get_user_profile(user_id: int):
=======
# Code from the branch being merged (e.g., feature/user-login)
def retrieve_user_profile_details(user_id: int, include_email: bool = False):
>>>>>>> feature/user-login</code></pre>
                                </li>
                                <li><strong>Resolve the Conflict:</strong> This is the human part. You need to:
                                    <ul>
                                        <li>Look at the changes between <code><<<<<<< HEAD</code> and <code>=======</code> (what's currently in <code>main</code>).</li>
                                        <li>Look at the changes between <code>=======</code> and <code>>>>>>>> your-branch-name</code> (what's in your feature branch).</li>
                                        <li>Decide what the code should look like. This might mean keeping one version, the other, or a combination of both.</li>
                                        <li><strong>Delete the Git markers</strong> (<code><<<<<<<</code>, <code>=======</code>, <code>>>>>>>></code>) after you've made your edits.</li>
                                    </ul>
                                </li>
                                <li><strong>Stage the Resolved File:</strong> Once you're happy with the merged code in the file:
                                    <pre class="code-block"><code>git add src/my_awesome_service/api/users.py</code></pre>
                                </li>
                                <li><strong>Commit the Merge:</strong> After resolving all conflicts and staging all conflicted files:
                                    <pre class="code-block"><code>git commit</code></pre>
                                    Git will often pre-populate a commit message like "Merge branch 'feature/user-login'". You can usually just save and close this message. If you initiated the merge via <code>git pull</code>, you might just need to <code>git add</code> and <code>git commit</code> (or <code>git rebase --continue</code> if you pulled with rebase).
                                </li>
                            </ol>
                            <h5>Tools Can Help:</h5>
                            <p>Many IDEs (like VS Code) have built-in merge conflict resolution tools that provide a side-by-side view, making it easier to see the differences and choose which changes to accept.</p>
                            <p>Understanding branching and how to handle merge conflicts are fundamental Git skills. Mastering them will make you a more confident and effective developer, especially when working in a team.</p>


                            <h4>5. Master <code>.gitignore</code>: Your Repo's Gatekeeper</h4>
                            <p>Your Git repository should only track files essential for building and running your project â€“ primarily source code and configuration. Everything else (generated files, environment secrets, large data, dependencies) should be explicitly ignored using a <code>.gitignore</code> file.</p>
                            <pre class="code-block"><code># Byte-compiled files and caches
__pycache__/
*.pyc
*.pyo
*.pyd
*.so
*.swp # Vim swap files

# Secrets / Environment variables
# NEVER commit sensitive credentials!
.env
.env.*
*.env
!.env.example  # Often good to commit a template

# OS-specific files
.DS_Store
Thumbs.db
Desktop.ini

# IDE / Editor folders
.idea/
.vscode/
*.sublime-project
*.sublime-workspace
nbproject/ # NetBeans

# Virtual environment folders
venv/
.venv/
env/
.env/
*_env/
env.bak/
venv.bak/

# Build artifacts & distribution files
dist/
build/
*.egg-info/
wheels/
*.tar.gz
*.whl
*.jar
*.war

# Test & Coverage artifacts
.pytest_cache/
.coverage
.coverage.*
htmlcov/
nosetests.xml
coverage.xml
*.cover
.hypothesis/

# Data files (Generally avoid in Git - use other storage)
*.csv
*.tsv
*.json  # If large dataset, not small config
*.xml   # If large dataset, not small config
*.yaml  # If large dataset, not small config
*.parquet
*.hdf5
*.h5
*.pkl
*.pickle
*.joblib
data/     # Often contains large files
*.db
*.sqlite
*.sqlite3

# Logs & temporary files
*.log
logs/
*.tmp
*.temp

# Node dependencies (if using Node.js tools)
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Python Notebook Checkpoints
.ipynb_checkpoints/
</code></pre>
                            <p>
                                 Large binary files (like datasets, models, images, videos) don't belong directly in Git. They bloat the repository, make cloning slow, and don't diff well. Need them for reproducibility?
                            </p>
                            <ul>
                                 <li>Store them in dedicated object storage (AWS S3, Google Cloud Storage, Azure Blob Storage, MinIO).</li>
                                 <li>Use tools specifically designed for versioning large files alongside code, like <a href="https://dvc.org/" target="_blank" rel="noopener noreferrer">DVC (Data Version Control)</a> or <a href="https://git-lfs.github.com/" target="_blank" rel="noopener noreferrer">Git LFS (Large File Storage)</a>. These tools store pointers in Git and manage the actual large files separately.</li>
                            </ul>


                            <h4>6. Quick-Start Checklist for New Grads</h4>
                            <table class="blog-table">
                                <thead>
                                    <tr>
                                        <th>Habit</th>
                                        <th>Tooling Example</th>
                                        <th>Payoff</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Atomic commits, clear messages</td>
                                        <td>Git CLI discipline, commitlint hooks</td>
                                        <td>Easy history navigation, faster reviews, simple reverts</td>
                                    </tr>
                                     <tr>
                                         <td>Push frequently to remote</td>
                                         <td>Git remote (GitHub, GitLab, etc.), CI Server</td>
                                         <td>Data safety net, rapid feedback loop, enables collaboration</td>
                                     </tr>
                                     <tr>
                                        <td>Use branches for all work</td>
                                        <td><code>git checkout -b</code>, Pull/Merge Requests</td>
                                        <td>Isolation, experimentation safety, cleaner main history</td>
                                     </tr>
                                     <tr>
                                        <td>Handle merge conflicts calmly</td>
                                        <td>IDE merge tools, <code>git status</code>, manual editing</td>
                                        <td>Integrate work smoothly, avoid losing changes</td>
                                     </tr>
                                    <tr>
                                        <td><code>.gitignore</code> non-source files</td>
                                        <td>Well-maintained <code>.gitignore</code>, DVC/LFS/Cloud Storage</td>
                                        <td>Lean repository, fast clones/pulls, clean diffs</td>
                                    </tr>
                                </tbody>
                            </table>

                            <h3>Final Word</h3>
                            <p>
                                Transitioning from academic projects to production code isn't about suddenly gaining years of experience overnight; it's about adopting professional <strong>habits</strong>. Commit small changes often. Push your work to the safety of a remote repository regularly. Branch out for every task. Learn to merge confidently. Keep your repository clean and focused on source code. These practices might feel like extra effort initially, but they quickly become second nature and save enormous amounts of time and stress down the line (take it from someone who learned the hard way!).
                            </p>
                            <p>
                                So, before you switch tabs or close this window, make it a habit:
                            </p>
                            <pre class="code-block"><code>git status # Check what you've changed
git add . # Stage relevant changes
git commit -m "docs: internalize lessons on production git habits" # Meaningful message!
git push origin your-branch-name # Push to the cloud!</code></pre>
                            <p>
                                Your future self, potentially debugging late at night or recovering from a hardware hiccup, will thank you. ðŸš€
                            </p>

                        </div> <!-- End blog-post-text -->
                    </section> <!-- End blog-post-content -->

                </div> <!-- End blog-post-content-wrapper -->

            </article> <!-- End blog-post-article -->

        </div> <!-- End main-content -->

    </main>

    <!-- Custom JS -->
    <script src="../assets/js/script.js"></script>
    <!-- Ionicon -->
    <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>

</body>

</html>